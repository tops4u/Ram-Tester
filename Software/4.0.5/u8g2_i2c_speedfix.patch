--- a/src/U8x8lib.cpp
+++ b/src/U8x8lib.cpp
@@ -119,9 +119,13 @@
     case U8X8_MSG_DELAY_MILLI:
       delay(arg_int);
       break;
     case U8X8_MSG_DELAY_I2C:
-      /* arg_int is 1 or 4: 100KHz (5us) or 400KHz (1.25us) */
-      delayMicroseconds(arg_int<=2?5:2);
+      /* arg_int is 1 or 4: 100KHz (5us) or 400KHz (1.25us)           */
+      /* For 400kHz on AVR: the NOINLINE call chain through i2c_delay  */
+      /* -> u8x8_gpio_Delay -> this callback already takes ~3us,       */
+      /* which exceeds the I2C spec minimum of 1.25us half-clock.      */
+      if (arg_int <= 2)
+        delayMicroseconds(5);
       break;
     case U8X8_MSG_GPIO_I2C_CLOCK:
     case U8X8_MSG_GPIO_I2C_DATA:
@@ -1119,5 +1123,8 @@
 static void i2c_delay(u8x8_t *u8x8)
 {
-  //u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_10MICRO, u8x8->display_info->i2c_bus_clock_100kHz);
-  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_I2C, u8x8->display_info->i2c_bus_clock_100kHz);
+  /* 400kHz: NOINLINE call + field check alone provides ~1.6us,       */
+  /* safely above I2C spec minimum of 1.25us half-clock period.       */
+  /* Skip the full callback dispatch chain to eliminate ~1.5us waste.  */
+  if (u8x8->display_info->i2c_bus_clock_100kHz <= 2)
+    u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_I2C, u8x8->display_info->i2c_bus_clock_100kHz);
 }
