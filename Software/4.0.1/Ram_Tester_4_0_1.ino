/*
=====================================
RAM Tester Program for RAM Tester PCB
=====================================

Author:   Andreas Hoffmann
Project:  github.com/tops4u/ram-tester
Version:  4.0.1
Date:     25.01.2026

This software is published under GPL 3.0. Respect the license terms.
Project hosted at: https://github.com/tops4u/Ram-Tester/

Note: The code contains duplication and is not designed for elegance or efficiency.
The goal was to make it work lightning fast!

=======================================================================================
 LED BLINK CODE REFERENCE
=======================================================================================
 The bi-color LED is used to indicate test results, detected RAM type,
 and error conditions.

 Blink sequences are grouped into two parts:
   1. GREEN blinks  -> Success indicator (all tests passed)
   2. ORANGE blinks -> RAM type identification

 Sequence format: [GREEN blinks] pause [ORANGE blinks] pause → repeats

---------------------------------------------------------------------------------------
 SUCCESS CODES (RAM detected and tested OK)
---------------------------------------------------------------------------------------
   1 GREEN, 1 ORANGE : 4164   (64Kx1, 16-pin)
   1 GREEN, 2 ORANGE : 41256  (256Kx1, 16-pin)
   1 GREEN, 3 ORANGE : 41257  (256Kx1 Nibble Mode, 16-pin)
   1 GREEN, 4 ORANGE : 4816   (16Kx1, 16-pin)
   1 GREEN, 5 ORANGE : 4532-L (32Kx1 Lower Half, 16-pin, half-good chip)
   1 GREEN, 6 ORANGE : 4532-H (32Kx1 Upper Half, 16-pin, half-good chip)

   2 GREEN, 1 ORANGE : 4416   (16Kx4, 18-pin)
   2 GREEN, 2 ORANGE : 4464   (64Kx4, 18-pin)
   2 GREEN, 3 ORANGE : 411000 (1Mx1, 18-pin)

   3 GREEN, 1 ORANGE : 514256 (256Kx4, 20-pin)
   3 GREEN, 2 ORANGE : 514400 (1Mx4, 20-pin)
   3 GREEN, 3 ORANGE : 514258 (256Kx4 Static Column, 20-pin)
   3 GREEN, 4 ORANGE : 514402 (1Mx4 Static Column, 20-pin)

   4 GREEN, 1 ORANGE : 4116   (16Kx1, tested via 20-pin adapter)
   4 GREEN, 2 ORANGE : 4027   (4Kx1, tested via 20-pin adapter)

---------------------------------------------------------------------------------------
 ERROR CODES (RAM missing, wiring issue, or failure during testing)
---------------------------------------------------------------------------------------
   Continuous fast RED blinks    : Configuration error (DIP switch invalid)
   Continuous slow RED blinks    : No RAM detected in socket
   1 RED, n ORANGE blinks        : Address line error (n = address line number 0-15)
   2 RED, 1-6 ORANGE blinks      : Pattern error (1-5 = pattern 0-4, 6 = random test)
   2 RED, 7 ORANGE blinks        : Retention error (data not held during refresh)
   3 RED, n ORANGE blinks        : Ground short (n = pin number)

---------------------------------------------------------------------------------------
 NOTE:
 - Error codes are generated by error() and ConfigFail() functions in common.cpp
 - When an error is found, the test stops and the corresponding blink code repeats
 - Success codes repeat continuously until power is removed or reset button pressed
=======================================================================================

Test Methodology:
- All DRAMs are tested using Page Mode for reading and writing
- DRAMs with 4-bit data bus tested column-by-column with patterns: 0b0000, 0b1111, 0b1010, 0b0101
- Program tests data retention times (not access times or voltage levels)
- Address decoding and crosstalk verified using pseudo-randomized data patterns
- Special handling for 4532 chips (half-functional 4164 variants)

Test Patterns (in order):
  0. 0x00 - All zeros (stuck-at-0 test)
  1. 0xFF - All ones (stuck-at-1 test)
  2. 0xAA - Alternating bits (column short test)
  3. 0x55 - Alternating bits inverted (column short test)
  4. Random pattern (address decoder and crosstalk test)
  5. Random pattern inverted (full coverage retention test)

Version History:
- 1.0         Initial implementation for 20-pin DIP/ZIP, supporting 256x4 DRAM (e.g., MSM514256C).
- 1.1         Added auto-detection for 1M or 256k x4 DRAM.
- 1.2         Support for 256kx1 DRAM (e.g., 41256).
- 1.21        Added column address line checks for 41256/4164, ensuring all address lines, buffers, and column decoders work.
- 1.22        Added checks for 4164/41256 DRAMs.
- 1.23        Added row address checking for 4164/41256, complementing column checks from version 1.21.
- 1.3         Full row and column tests for pins, buffers, and decoders on 514256 and 441000 DRAMs.
- 1.4         Support for 4416/4464 added. Only 4416 tested as 4464 test chips were unavailable.
- 2.0pre1     Introduced row crosstalk and refresh time checks (2ms for 4164, 4ms for 41256, 8ms for 20-pin DRAM types).
- 2.0pre      Refresh tests for 4416/4464 not yet included. Enabled ground short tests and cleaned 20-pin code section.
- 2.0         Fixed bugs for 4464 and adjusted refresh timing.
- 2.1         Added a test mode for installation checks after soldering. Test mode instructions available on GitHub.
              To exit test mode: set all DIP switches to ON, reset, set DIP switches to OFF, and reset again.
- 2.1.1       Fixed minor bugs in test patterns and I/O configuration for 18-pin RAM.
- 2.1.2       Bug fix for 18Pin Versions (error in address line to physical port decoding)
- 2.2.0a      Adding Static Column Tests for 514258
- 2.2.0b      Added Random Bit Test for 20pin Types - this slightly prolongs Testing
- 2.3.0a      Major rework on Retention Testing. Introduced RAM Types for timing. Added OLED support.
              Speed optimization in the Code to keep longer test times of pseudo random data at bay.
              Minor Bugfix 16Bit had one col/row overrun - buggy but no negative side effects
- 2.3.0.pre   All functional targets for 2.3.0 are met. OLED Tested and working
- 2.3.0.pre2  Checked and updated all Retention Timings. Fixed some minor Typos. Added 514402 Static Column 1Mx4 RAM
- 2.3.0       Option to deactivate OLED in Code (remove the line: #define OLED)
              Code Version output in DIP Switch Error Screen.
- 2.3.1       Improved Address & Decoder Checks. RAM Inserted? Display
- 2.3.1.fix   Timing issue with 20Pin address tests
- 2.4.0       Implemented Tests for 41C1000 DIP 1Mx1 Chip
              Various speed improvements for all RAM, resulting in up to 40% shorter Tests
- 2.4.1       Added Random data inversion for every second run. This ensures all Cells are
              Retention Tested if the user wants this. This is using the EEPROM but with wear leveling
- 2.4.2       Bugfix for EEPROM wear leveling algorithm. It stopped working after the first EEPROM Cell was full.
- 2.5.0       Implementation for Adapter board for 4116 RAM
- 2.5.1       Fixing some Bugs from 2.5.0 and introducing better RAM Present checks
              Code restructured into modular architecture with separate files for each pin configuration
              Support for HM4816 added
- 3.0.0       New Major Version due to significant changes in code and behaviour.
              Fixed a minor Bug in 20 Pin Testing. For Patterns 0 & 1 only the first 256 Col have been tested still broken cells are detected in later tests.
              Fixed a bug that might cause False Positives in Retention/Random Testing
- 3.0.1       Bugfix: Missing IO Direction Switching for Patterns 0&1 leads to false positive for 20Pin
- 3.1.0       New RAMs supported: 4816 16kx1 like 4164 without -5V/12V and 4027 -> Requires 4116 Adapter: 4Kx1 requires -5V/12V
- 3.1.1       Fixed 4027 Detection Routine
- 4.0.0.alpha Code Streamlining. 
              Added Help and Selfcheck Functions.
              Preliminary Support for 4532 (half-functional 4164 variants: 4532-L and 4532-H)
              Hidden CAS before RAS Refresh checks for all Rams that support this. 
              Open Points: Verify 4532 RAMS / Verify Refresh Check Delays. 
- 4.0.1       Adapted for 1Bit RAM witch has connected Din to Dout for in Circuit tests, like CBM A501

Disclaimer:
This project is for hobbyist use. There are no guarantees regarding its fitness for a specific purpose
or its error-free operation. Use it at your own risk.

----------------------------- COPYRIGHT INFORMATION -----------------------------

 * This project uses components of the Arduino platform, licensed under the LGPL 2.1:
 * - Arduino Core (Arduino.h, EEPROM.h)
 * -----------------------------
 * It also uses avr-libc (avr/pgmspace.h, avr/io.h), licensed under a BSD-style license.
 * -----------------------------
 * This product uses the U8g2 graphics library.
 *
 * Copyright (c) 2016, olikraus
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


//=======================================================================================
// INCLUDES
//=======================================================================================

#include "common.h"
#include "16Pin.h"
#include "18Pin.h"
#include "20Pin.h"

//=======================================================================================
// ARDUINO SETUP FUNCTION
//=======================================================================================

/**
 * Initialize hardware and start appropriate RAM test based on DIP switch configuration
 *
 * This function is called once at startup and performs the following sequence:
 * 1. Initialize OLED display (if enabled)
 * 2. Configure all I/O ports as inputs with pullups disabled
 * 3. Read DIP switches to determine RAM pin configuration (16/18/20-pin)
 * 4. Validate DIP switch configuration
 * 5. Enable pullups on all I/O pins
 * 6. Check for ground shorts on all pins
 * 7. Initialize DRAM with RAS-only refresh cycles
 * 8. Route to appropriate test function based on pin configuration
 *
 * DIP Switch Configuration (read from pins 19, 3, 2):
 * - Pin 19 (A5): 20-pin mode if HIGH
 * - Pin 3 (D3): 18-pin mode if HIGH
 * - Pin 2 (D2): 16-pin mode if HIGH
 *
 * Valid configurations (only one pin should be HIGH):
 * - Mode_16Pin (2): Tests 4164, 41256, 41257, 4816, 4532-L, 4532-H
 * - Mode_18Pin (3): Tests 4416, 4464, 411000
 * - Mode_20Pin (5): Tests 514256, 514258, 514400, 514402, 4116, 4027
 *
 * Invalid configurations trigger ConfigFail() which shows error on OLED
 * and blinks LED in fast red pattern.
 *
 * Note: This function never returns during normal operation. Test functions
 * either call testOK() (infinite success blink) or error() (infinite error blink).
 */
void setup() {
#ifdef OLED
  // Initialize OLED display with I2C bus at 400kHz for faster updates
  display.begin();
  display.setBusClock(400000);
  display.setPowerSave(0);
#endif

  // Configure all I/O ports as inputs (DDR=0 means input)
  // Preserve upper 3 bits of each port which may be used by Arduino core
  DDRB &= 0b11100000;  // PB0-PB4 as inputs (bits 5-7 preserved)
  DDRC &= 0b11000000;  // PC0-PC5 as inputs (bits 6-7 preserved for ADC)
  DDRD = 0x00;         // PD0-PD7 all as inputs

  // Read DIP switch configuration from three pins
  // Each pin represents a different RAM pin configuration mode
  if (digitalRead(19) == 1) {  // A5 -> 20-pin mode
    Mode += Mode_20Pin;
  }
  if (digitalRead(3) == 1) {   // D3 -> 18-pin mode
    Mode += Mode_18Pin;
  }
  if (digitalRead(2) == 1) {   // D2 -> 16-pin mode
    Mode += Mode_16Pin;
  }

  // Validate DIP switch configuration
  // Valid: Mode_16Pin(2), Mode_18Pin(3), Mode_20Pin(5)
  // Invalid: 0,1,4,6,7... (no switches or multiple switches set)
  if (Mode < 2 || Mode > 5) {
#ifdef OLED
    if (Mode < 2)
      selfCheck();
    // Display configuration error with QR code to documentation
    printQRandVersion("Check DIP");
#endif
    ConfigFail();  // Never returns - infinite fast red blink
  }

  // Enable pullup resistors on all I/O pins for proper signal detection
  // Pullups allow detection of floating pins and ground shorts
  PORTB |= 0b00011111;  // Enable pullups on PB0-PB4
  PORTC |= 0b00111111;  // Enable pullups on PC0-PC5
  PORTD = 0xff;         // Enable pullups on all PORTD pins

  // Turn on LED on PB5 (pin 13) to indicate tester is active
  // This prevents user confusion as it will show yellow (red+green) during test
  digitalWrite(LED_RED_PIN, ON);

  // Allow time for pullup resistors to charge pins to HIGH state
  // Check for any pins shorted to ground (would remain LOW with pullup enabled)
  checkGNDShort();  // Calls error() if short detected, never returns

  // DRAM startup delay as specified in datasheets
  // Most DRAMs require 200μs minimum after power-up before initialization
  delayMicroseconds(200);

  // Generate pseudo-random test data table at startup
  // Saves 188 bytes flash compared to pre-populated table
  generateRandomTable();

  // Route to appropriate test function based on validated Mode
  // Each test function performs 8 RAS-only refresh cycles then runs full test suite
  if (Mode == Mode_20Pin) {
    initRAM(RAS_20PIN, CAS_20PIN);  // Initialize with 8 ROR cycles
    test_20Pin();                    // Never returns
  }
  if (Mode == Mode_18Pin) {
    initRAM(RAS_18PIN, CAS_18PIN);  // Initialize with 8 ROR cycles
    test_18Pin();                    // Never returns
  }
  if (Mode == Mode_16Pin) {
    initRAM(RAS_16PIN, CAS_16PIN);  // Initialize with 8 ROR cycles
    test_16Pin();                    // Never returns
  }
}

//=======================================================================================
// ARDUINO MAIN LOOP
//=======================================================================================

/**
 * Arduino main loop - should never be reached during normal operation
 *
 * This function is called repeatedly after setup() completes. However, in the
 * RAM Tester, setup() never returns because test functions end in infinite
 * loops (either testOK() for success or error() for failures).
 *
 * If this loop is somehow reached, it indicates a configuration failure or
 * unexpected code flow, so it triggers the configuration error state with
 * fast red LED blinking.
 *
 * Note: This is a safety fallback and should never execute in normal operation.
 */
void loop() {
  ConfigFail();  // Never returns - infinite fast red blink
}
